#!/usr/bin/env ruby
# frozen_string_literal: true
# encoding: utf-8

# Ensure UTF-8 encoding for all file I/O
Encoding.default_external = Encoding::UTF_8
Encoding.default_internal = Encoding::UTF_8

# KairosChain - Memory-driven agent framework
#
# Usage:
#   kairos-chain                        # stdio mode (default, for Cursor local)
#   kairos-chain --http                 # Streamable HTTP mode (remote access)
#   kairos-chain --http --port 9090
#   kairos-chain --init-admin           # Generate initial admin token
#   kairos-chain init [DIR]             # Initialize data directory with templates
#   kairos-chain init --data-dir /path  # Initialize at specific path
#   kairos-chain upgrade                # Preview template migrations after gem update
#   kairos-chain upgrade --apply        # Apply template migrations
#
# Data directory resolution (priority order):
#   1. --data-dir CLI option
#   2. KAIROS_DATA_DIR environment variable
#   3. .kairos/ in the current working directory
#
# Streamable HTTP mode requires: gem install puma rack

require 'optparse'

# Check for subcommands first (before OptionParser)
case ARGV[0]
when 'skillset'
  ARGV.shift # Remove 'skillset' from ARGV

  $LOAD_PATH.unshift File.expand_path('../lib', __dir__)
  require 'kairos_mcp'

  # Handle --data-dir before subcommand
  if (idx = ARGV.index('--data-dir'))
    KairosMcp.data_dir = File.expand_path(ARGV[idx + 1])
    ARGV.delete_at(idx + 1)
    ARGV.delete_at(idx)
  end

  require 'kairos_mcp/skillset_manager'

  action = ARGV.shift
  manager = KairosMcp::SkillSetManager.new

  case action
  when 'list'
    skillsets = manager.all_skillsets
    if skillsets.empty?
      puts "No SkillSets installed."
      puts "Install with: kairos-chain skillset install <path>"
    else
      puts "Installed SkillSets:"
      puts ""
      skillsets.each do |ss|
        status = manager.enabled?(ss.name) ? "enabled" : "disabled"
        puts "  #{ss.name} v#{ss.version} [#{ss.layer}] (#{status})"
        puts "    #{ss.description}" unless ss.description.empty?
        puts "    Tools: #{ss.tool_class_names.size}, Deps: #{ss.depends_on.join(', ') || 'none'}"
        puts ""
      end
    end

  when 'install'
    source = ARGV.shift
    unless source
      $stderr.puts "Usage: kairos-chain skillset install <path> [--layer L0|L1|L2]"
      exit 1
    end

    layer_override = nil
    if (idx = ARGV.index('--layer'))
      layer_override = ARGV[idx + 1]&.to_sym
      ARGV.delete_at(idx + 1)
      ARGV.delete_at(idx)
    end

    result = manager.install(source, layer_override: layer_override)
    puts "Installed SkillSet '#{result[:name]}' v#{result[:version]} [#{result[:layer]}]"
    puts "Path: #{result[:path]}"

  when 'enable'
    name = ARGV.shift
    unless name
      $stderr.puts "Usage: kairos-chain skillset enable <name>"
      exit 1
    end
    result = manager.enable(name)
    if result[:success]
      puts "Enabled SkillSet '#{name}'"
    else
      $stderr.puts "Error: #{result[:error]}"
      exit 1
    end

  when 'disable'
    name = ARGV.shift
    unless name
      $stderr.puts "Usage: kairos-chain skillset disable <name>"
      exit 1
    end
    result = manager.disable(name)
    if result[:success]
      puts "Disabled SkillSet '#{name}'"
    else
      $stderr.puts "Error: #{result[:error]}"
      exit 1
    end

  when 'remove'
    name = ARGV.shift
    unless name
      $stderr.puts "Usage: kairos-chain skillset remove <name>"
      exit 1
    end
    result = manager.remove(name)
    if result[:success]
      puts "Removed SkillSet '#{name}'"
    else
      $stderr.puts "Error: #{result[:error]}"
      exit 1
    end

  when 'info'
    name = ARGV.shift
    unless name
      $stderr.puts "Usage: kairos-chain skillset info <name>"
      exit 1
    end
    info = manager.info(name)
    if info
      puts "SkillSet: #{info[:name]} v#{info[:version]}"
      puts "  Description: #{info[:description]}"
      puts "  Author: #{info[:author]}"
      puts "  Layer: #{info[:layer]}"
      puts "  Enabled: #{info[:enabled]}"
      puts "  Dependencies: #{info[:depends_on].empty? ? 'none' : info[:depends_on].join(', ')}"
      puts "  Provides: #{info[:provides].join(', ')}"
      puts "  Tools: #{info[:tool_classes].join(', ')}"
      puts "  Path: #{info[:path]}"
    else
      $stderr.puts "SkillSet '#{name}' not found."
      exit 1
    end

  when 'package'
    name = ARGV.shift
    unless name
      $stderr.puts "Usage: kairos-chain skillset package <name>"
      exit 1
    end
    begin
      pkg = manager.package(name)
      require 'json'
      puts JSON.pretty_generate(pkg)
    rescue SecurityError => e
      $stderr.puts "Error: #{e.message}"
      exit 1
    end

  when 'install-archive'
    source = ARGV.shift
    archive_json = if source && source != '-'
                     File.read(source)
                   else
                     $stdin.read
                   end

    require 'json'
    archive_data = JSON.parse(archive_json)

    layer_override = nil
    if (idx = ARGV.index('--layer'))
      layer_override = ARGV[idx + 1]&.to_sym
    end

    begin
      result = manager.install_from_archive(archive_data, layer_override: layer_override)
      puts "Installed SkillSet '#{result[:name]}' v#{result[:version]} [#{result[:layer]}] from archive"
      puts "Path: #{result[:path]}"
      puts "Content hash: #{result[:content_hash]}"
    rescue SecurityError => e
      $stderr.puts "Security error: #{e.message}"
      exit 1
    end

  else
    puts "Usage: kairos-chain skillset <command>"
    puts ""
    puts "Commands:"
    puts "  list                               List installed SkillSets"
    puts "  install <path> [--layer L0|L1|L2]  Install a SkillSet from path"
    puts "  enable <name>                      Enable a SkillSet"
    puts "  disable <name>                     Disable a SkillSet"
    puts "  remove <name>                      Remove a SkillSet"
    puts "  info <name>                        Show SkillSet details"
    puts "  package <name>                     Package a knowledge-only SkillSet as JSON archive"
    puts "  install-archive <file|->           Install a SkillSet from JSON archive"
  end
  exit

when 'init'
  ARGV.shift  # Remove 'init' from ARGV

  init_options = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: kairos-chain init [options] [DIR]"

    opts.on('--data-dir DIR', 'Data directory path (default: .kairos/)') do |dir|
      init_options[:data_dir] = dir
    end

    opts.on('-h', '--help', 'Show help') do
      puts opts
      exit
    end
  end.parse!

  # Remaining argument is the directory
  init_dir = init_options[:data_dir] || ARGV.shift

  # Setup load path and require entry point
  $LOAD_PATH.unshift File.expand_path('../lib', __dir__)
  require 'kairos_mcp'

  # Set data_dir if specified, otherwise use default
  if init_dir
    KairosMcp.data_dir = File.expand_path(init_dir)
  end

  require 'kairos_mcp/initializer'
  KairosMcp::Initializer.run
  exit

when 'upgrade'
  ARGV.shift  # Remove 'upgrade' from ARGV

  upgrade_options = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: kairos-chain upgrade [options]"

    opts.on('--data-dir DIR', 'Data directory path (default: .kairos/)') do |dir|
      upgrade_options[:data_dir] = dir
    end

    opts.on('--apply', 'Apply the upgrade (default: preview only)') do
      upgrade_options[:apply] = true
    end

    opts.on('-h', '--help', 'Show help') do
      puts opts
      exit
    end
  end.parse!

  # Setup load path and require entry point
  $LOAD_PATH.unshift File.expand_path('../lib', __dir__)
  require 'kairos_mcp'

  # Set data_dir if specified
  if upgrade_options[:data_dir]
    KairosMcp.data_dir = File.expand_path(upgrade_options[:data_dir])
  end

  require 'kairos_mcp/upgrade_analyzer'
  require 'kairos_mcp/config_merger'
  require 'kairos_mcp/tools/system_upgrade'

  # Create a minimal tool instance for CLI use
  tool = KairosMcp::Tools::SystemUpgrade.new
  command = upgrade_options[:apply] ? 'apply' : 'preview'
  result = tool.call({ 'command' => command, 'approved' => upgrade_options[:apply] || false })

  # Extract text from MCP response format
  result.each do |content|
    puts content[:text] if content[:type] == 'text'
  end
  exit
end

# Parse CLI options
options = {}

OptionParser.new do |opts|
  opts.banner = "Usage: kairos-chain [options]"

  opts.on('--data-dir DIR', 'Data directory path (default: .kairos/ or KAIROS_DATA_DIR)') do |dir|
    options[:data_dir] = dir
  end

  opts.on('--http', 'Start in Streamable HTTP mode (default: stdio)') do
    options[:http] = true
  end

  opts.on('--port PORT', Integer, 'HTTP port (default: 8080)') do |port|
    options[:port] = port
  end

  opts.on('--host HOST', 'HTTP bind host (default: 0.0.0.0)') do |host|
    options[:host] = host
  end

  opts.on('--init-admin', 'Generate initial admin token and exit') do
    options[:init_admin] = true
  end

  opts.on('--token-store PATH', 'Path to token store file') do |path|
    options[:token_store] = path
  end

  opts.on('-v', '--version', 'Show version') do
    options[:version] = true
  end

  opts.on('-h', '--help', 'Show help') do
    puts opts
    puts ""
    puts "Subcommands:"
    puts "  init [DIR]          Initialize data directory with default templates"
    puts "  upgrade [--apply]   Check/apply template migrations after gem update"
    puts "  skillset <cmd>      Manage SkillSet plugins (list/install/enable/disable/remove/info)"
    exit
  end
end.parse!

# Setup bundler if Gemfile exists AND vendor/bundle is installed.
# IMPORTANT: Only activate Bundler when vendor/bundle exists. Once bundler/setup
# is loaded, it permanently hooks into Ruby's require mechanism. If the bundle is
# incomplete or missing, all subsequent gem requires will fail with LoadError,
# even inside a rescue block. By guarding on vendor/bundle, we ensure Ruby's
# native gem loading works with system gems when Bundler is not needed.
gemfile_path = File.expand_path('../Gemfile', __dir__)
vendor_path = File.expand_path('../vendor/bundle', __dir__)
if File.exist?(gemfile_path) && File.directory?(vendor_path)
  ENV['BUNDLE_GEMFILE'] ||= gemfile_path
  ENV['BUNDLE_PATH'] ||= vendor_path
  begin
    require 'bundler/setup'
  rescue StandardError, LoadError => e
    warn "[KairosChain] Bundler setup failed (#{e.class}): #{e.message}"
    warn "[KairosChain] Falling back to system gems"
  end
end

$LOAD_PATH.unshift File.expand_path('../lib', __dir__)

# Load entry point
require 'kairos_mcp'

# Set data_dir if specified via CLI
if options[:data_dir]
  KairosMcp.data_dir = File.expand_path(options[:data_dir])
end

# Handle --version
if options[:version]
  puts "KairosChain MCP Server v#{KairosMcp::VERSION}"
  puts "Data directory: #{KairosMcp.data_dir}"
  exit
end

# Handle --init-admin
if options[:init_admin]
  require 'kairos_mcp/auth/token_store'

  store = KairosMcp::Auth::TokenStore.new(options[:token_store])

  if !store.empty?
    $stderr.puts "[WARNING] Active tokens already exist."
    $stderr.puts "Use the token_manage MCP tool to create additional tokens."
    $stderr.puts ""
    $stderr.puts "Existing tokens:"
    store.list.each do |t|
      $stderr.puts "  - #{t[:user]} (#{t[:role]}, expires: #{t[:expires_at] || 'never'})"
    end
    $stderr.puts ""
    $stderr.puts "Proceed anyway? (y/N)"
    answer = $stdin.gets&.strip
    exit unless answer&.downcase == 'y'
  end

  result = store.create(user: 'admin', role: 'owner', issued_by: 'system')

  puts ""
  puts "=" * 60
  puts "  KairosChain Admin Token Generated"
  puts "=" * 60
  puts ""
  puts "  Token: #{result['raw_token']}"
  puts "  User:  #{result['user']}"
  puts "  Role:  #{result['role']}"
  puts "  Expires: #{result['expires_at'] || 'never'}"
  puts ""
  puts "  IMPORTANT: Store this token securely."
  puts "  It will NOT be shown again."
  puts ""
  puts "  Configure in Cursor mcp.json:"
  puts "  {"
  puts "    \"mcpServers\": {"
  puts "      \"kairos\": {"
  puts "        \"url\": \"http://localhost:#{options[:port] || 8080}/mcp\","
  puts "        \"headers\": {"
  puts "          \"Authorization\": \"Bearer #{result['raw_token']}\""
  puts "        }"
  puts "      }"
  puts "    }"
  puts "  }"
  puts ""
  puts "=" * 60
  exit
end

# Auto-initialize if data directory doesn't exist
unless KairosMcp.initialized?
  $stderr.puts "[KairosChain] Data directory not initialized at: #{KairosMcp.data_dir}"
  $stderr.puts "[KairosChain] Run 'kairos-chain init' to set up, or auto-initializing..."
  require 'kairos_mcp/initializer'
  KairosMcp::Initializer.run(quiet: true)
end

# Handle --http (Streamable HTTP mode)
if options[:http]
  require 'kairos_mcp/http_server'

  server = KairosMcp::HttpServer.new(
    port: options[:port],
    host: options[:host],
    token_store_path: options[:token_store]
  )
  server.run
else
  # Default: stdio mode
  require 'kairos_mcp/server'
  KairosMcp::Server.run
end
