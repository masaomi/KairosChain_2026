#!/usr/bin/env ruby
# frozen_string_literal: true

# KairosChain - Memory-driven agent framework
#
# Usage:
#   kairos-chain                        # stdio mode (default, for Cursor local)
#   kairos-chain --http                 # Streamable HTTP mode (remote access)
#   kairos-chain --http --port 9090
#   kairos-chain --init-admin           # Generate initial admin token
#   kairos-chain init [DIR]             # Initialize data directory with templates
#   kairos-chain init --data-dir /path  # Initialize at specific path
#   kairos-chain upgrade                # Preview template migrations after gem update
#   kairos-chain upgrade --apply        # Apply template migrations
#
# Data directory resolution (priority order):
#   1. --data-dir CLI option
#   2. KAIROS_DATA_DIR environment variable
#   3. .kairos/ in the current working directory
#
# Streamable HTTP mode requires: gem install puma rack

require 'optparse'

# Check for subcommands first (before OptionParser)
case ARGV[0]
when 'init'
  ARGV.shift  # Remove 'init' from ARGV

  init_options = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: kairos-chain init [options] [DIR]"

    opts.on('--data-dir DIR', 'Data directory path (default: .kairos/)') do |dir|
      init_options[:data_dir] = dir
    end

    opts.on('-h', '--help', 'Show help') do
      puts opts
      exit
    end
  end.parse!

  # Remaining argument is the directory
  init_dir = init_options[:data_dir] || ARGV.shift

  # Setup load path and require entry point
  $LOAD_PATH.unshift File.expand_path('../lib', __dir__)
  require 'kairos_mcp'

  # Set data_dir if specified, otherwise use default
  if init_dir
    KairosMcp.data_dir = File.expand_path(init_dir)
  end

  require 'kairos_mcp/initializer'
  KairosMcp::Initializer.run
  exit

when 'upgrade'
  ARGV.shift  # Remove 'upgrade' from ARGV

  upgrade_options = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: kairos-chain upgrade [options]"

    opts.on('--data-dir DIR', 'Data directory path (default: .kairos/)') do |dir|
      upgrade_options[:data_dir] = dir
    end

    opts.on('--apply', 'Apply the upgrade (default: preview only)') do
      upgrade_options[:apply] = true
    end

    opts.on('-h', '--help', 'Show help') do
      puts opts
      exit
    end
  end.parse!

  # Setup load path and require entry point
  $LOAD_PATH.unshift File.expand_path('../lib', __dir__)
  require 'kairos_mcp'

  # Set data_dir if specified
  if upgrade_options[:data_dir]
    KairosMcp.data_dir = File.expand_path(upgrade_options[:data_dir])
  end

  require 'kairos_mcp/upgrade_analyzer'
  require 'kairos_mcp/config_merger'
  require 'kairos_mcp/tools/system_upgrade'

  # Create a minimal tool instance for CLI use
  tool = KairosMcp::Tools::SystemUpgrade.new
  command = upgrade_options[:apply] ? 'apply' : 'preview'
  result = tool.call({ 'command' => command, 'approved' => upgrade_options[:apply] || false })

  # Extract text from MCP response format
  result.each do |content|
    puts content[:text] if content[:type] == 'text'
  end
  exit
end

# Parse CLI options
options = {}

OptionParser.new do |opts|
  opts.banner = "Usage: kairos-chain [options]"

  opts.on('--data-dir DIR', 'Data directory path (default: .kairos/ or KAIROS_DATA_DIR)') do |dir|
    options[:data_dir] = dir
  end

  opts.on('--http', 'Start in Streamable HTTP mode (default: stdio)') do
    options[:http] = true
  end

  opts.on('--port PORT', Integer, 'HTTP port (default: 8080)') do |port|
    options[:port] = port
  end

  opts.on('--host HOST', 'HTTP bind host (default: 0.0.0.0)') do |host|
    options[:host] = host
  end

  opts.on('--init-admin', 'Generate initial admin token and exit') do
    options[:init_admin] = true
  end

  opts.on('--token-store PATH', 'Path to token store file') do |path|
    options[:token_store] = path
  end

  opts.on('-v', '--version', 'Show version') do
    options[:version] = true
  end

  opts.on('-h', '--help', 'Show help') do
    puts opts
    puts ""
    puts "Subcommands:"
    puts "  init [DIR]          Initialize data directory with default templates"
    puts "  upgrade [--apply]   Check/apply template migrations after gem update"
    exit
  end
end.parse!

# Setup bundler if Gemfile exists (enables optional gems)
gemfile_path = File.expand_path('../Gemfile', __dir__)
if File.exist?(gemfile_path)
  ENV['BUNDLE_GEMFILE'] ||= gemfile_path
  # Use local vendor/bundle if it exists
  vendor_path = File.expand_path('../vendor/bundle', __dir__)
  ENV['BUNDLE_PATH'] ||= vendor_path if File.directory?(vendor_path)
  begin
    require 'bundler/setup'
  rescue Bundler::GemNotFound, LoadError
    # Fall back to running without bundler if gems not installed
    warn "[KairosChain] Bundler gems not found, running without optional dependencies"
  end
end

$LOAD_PATH.unshift File.expand_path('../lib', __dir__)

# Load entry point
require 'kairos_mcp'

# Set data_dir if specified via CLI
if options[:data_dir]
  KairosMcp.data_dir = File.expand_path(options[:data_dir])
end

# Handle --version
if options[:version]
  puts "KairosChain MCP Server v#{KairosMcp::VERSION}"
  puts "Data directory: #{KairosMcp.data_dir}"
  exit
end

# Handle --init-admin
if options[:init_admin]
  require 'kairos_mcp/auth/token_store'

  store = KairosMcp::Auth::TokenStore.new(options[:token_store])

  if !store.empty?
    $stderr.puts "[WARNING] Active tokens already exist."
    $stderr.puts "Use the token_manage MCP tool to create additional tokens."
    $stderr.puts ""
    $stderr.puts "Existing tokens:"
    store.list.each do |t|
      $stderr.puts "  - #{t[:user]} (#{t[:role]}, expires: #{t[:expires_at] || 'never'})"
    end
    $stderr.puts ""
    $stderr.puts "Proceed anyway? (y/N)"
    answer = $stdin.gets&.strip
    exit unless answer&.downcase == 'y'
  end

  result = store.create(user: 'admin', role: 'owner', issued_by: 'system')

  puts ""
  puts "=" * 60
  puts "  KairosChain Admin Token Generated"
  puts "=" * 60
  puts ""
  puts "  Token: #{result['raw_token']}"
  puts "  User:  #{result['user']}"
  puts "  Role:  #{result['role']}"
  puts "  Expires: #{result['expires_at'] || 'never'}"
  puts ""
  puts "  IMPORTANT: Store this token securely."
  puts "  It will NOT be shown again."
  puts ""
  puts "  Configure in Cursor mcp.json:"
  puts "  {"
  puts "    \"mcpServers\": {"
  puts "      \"kairos\": {"
  puts "        \"url\": \"http://localhost:#{options[:port] || 8080}/mcp\","
  puts "        \"headers\": {"
  puts "          \"Authorization\": \"Bearer #{result['raw_token']}\""
  puts "        }"
  puts "      }"
  puts "    }"
  puts "  }"
  puts ""
  puts "=" * 60
  exit
end

# Auto-initialize if data directory doesn't exist
unless KairosMcp.initialized?
  $stderr.puts "[KairosChain] Data directory not initialized at: #{KairosMcp.data_dir}"
  $stderr.puts "[KairosChain] Run 'kairos-chain init' to set up, or auto-initializing..."
  require 'kairos_mcp/initializer'
  KairosMcp::Initializer.run(quiet: true)
end

# Handle --http (Streamable HTTP mode)
if options[:http]
  require 'kairos_mcp/http_server'

  server = KairosMcp::HttpServer.new(
    port: options[:port],
    host: options[:host],
    token_store_path: options[:token_store]
  )
  server.run
else
  # Default: stdio mode
  require 'kairos_mcp/server'
  KairosMcp::Server.run
end
