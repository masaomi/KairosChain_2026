# KairosChain: 監査可能なAI進化のための自己改変型Pure Agent Skills

**Masaomi Hatakeyama**  
Genomics on Blockchain  
2026年1月18日

---

## 概要

AIエージェントの能力進化は、根本的に不透明なままである。AIシステムが改善されたり、行動を変化させたり、潜在的に危険になったりした場合でも、その能力形成の因果プロセスを第三者が検証することはできない。本論文では、AIスキルの進化をプライベートブロックチェーン上に記録するメタ台帳であるKairosChainを紹介する。KairosChainは、Ruby DSLと抽象構文木（AST）を用いた実行可能なスキル定義であるPure Agent Skillsと、ルールは修正できるがその修正履歴は消去できないMinimum-Nomic原則を組み合わせている。本システムは法体系に着想を得た階層型アーキテクチャを実装し、不変の哲学（憲法）、進化可能なメタルール（法律）、プロジェクト知識（政令）、一時的コンテキスト（通達）を分離している。すべてのスキル状態遷移（誰が、何を、いつ、どのように変更したか）を不変のチェーンに記録することで、KairosChainはAI説明可能性への新しいアプローチを提供する：結果が正しいかどうかではなく、それを生み出した知性がどのように形成されたかを説明する。

**キーワード:** AI説明可能性、エージェントスキル、自己改変、ブロックチェーン、監査証跡、Minimum-Nomic、Ruby DSL、階層型アーキテクチャ、自己参照制約

---

## 1. はじめに

大規模言語モデル（LLM）エージェントやAIコーディングアシスタントはますます高性能になっているが、その能力形成プロセスはブラックボックスのままである。プロンプトは揮発性であり、ツール呼び出し履歴は断片的であり、スキルの進化—その再定義、合成、削除—は痕跡を残さない。その結果、AIエージェントがより高性能になったり、行動を変化させたり、潜在的に有害な特性を示したりしても、現在の状態に至る因果プロセスを独立して検証することはできない。

skills.mdファイルのような現在のAIスキル管理アプローチは、スキルを静的なテキストドキュメントとして扱う。このアプローチには根本的な限界がある：スキル間の依存関係は未検証のままであり、スキル間の矛盾は検出されず、変更の根拠は追跡不能になる。この状況は、ソフトウェアエンジニアリングにおける無制限のグローバル変数というアンチパターンに似ている—最初は便利だが、システムが成長するにつれてますます混沌とする。

この不透明性は、AIガバナンスと説明責任に重大な課題をもたらす[1]。AIスキル構成を評価するフレームワークが提案されている[2]が、これらのアプローチは時間経過に伴う能力の動的な進化ではなく、静的なスナップショットに焦点を当てている。

KairosChainは、AIスキル進化の監査可能な記録を提供することで、このギャップに対処する。ルールは変更できるが変更履歴は永続的である自己改変ゲームであるMinimum Nomicの概念[3]に基づき、KairosChainは「この知性はどのように形成されたか？」という問いに答えるメタ台帳を作成する。

KairosChainの核心的洞察は、3つの概念の明示的な分離である：

- **STATE（状態）**: 現在どのような能力が存在するか
- **CHANGE（変更）**: 能力がどのように修正されているか
- **CONSTRAINT（制約）**: その修正が許可されているか

変更そのものを第一級の対象として扱うことで、KairosChainはAI能力の監査可能な進化を可能にする。

---

## 2. 関連研究

### 2.1 エージェントスキルと能力のモジュール化

AnthropicのClaude Agent Skills[4]は、再利用可能でドメイン固有の専門知識モジュールのパラダイムを導入した。スキルはメタデータ（常にロード）、指示（タスク呼び出し時にロード）、リソース（オンデマンドでロード）で構成され、専門性を維持しながら効率的なコンテキストウィンドウ利用を可能にする。この3層アーキテクチャはKairosChainのPure Agent Skills設計に影響を与えている。

Yuら[2]は、AIモデルが複雑なタスクに対処するために複数のスキルをどのように組み合わせるかを評価するフレームワークであるSkill-Mixを提案した。このようなフレームワークは推論時のスキル構成を評価するが、KairosChainはスキル定義自体を時間経過とともに監査可能でバージョン管理されたものにすることに焦点を当てている。

### 2.2 自己改変とルールダイナミクス

畠山と橋本[3]は、ルールダイナミクスを研究するためのモデルとしてMinimum Nomicを提案した。Suberのオリジナルのノミックゲーム[5]から派生したMinimum Nomicは、進化可能性を促進しながら自己改変の本質を保持する。重要な洞察は、ルールは変更できるが、変更プロセス自体は観察可能で記録可能でなければならないということである。KairosChainはこの原則をAIスキル定義に適用する：スキルは進化できるが、進化履歴は不変である。

### 2.3 AIガバナンスと説明責任

Priyanshuら[1]は、Claudeをケーススタディとして使用してAIガバナンスの課題を分析し、透明性と説明責任メカニズムの必要性を強調した。AIエージェントがより自律的になるにつれて、その目的と能力が時間とともにどのように進化するかを追跡することが不可欠になる。KairosChainは、スキル定義レベルでそのような追跡のためのインフラストラクチャを提供する。

### 2.4 自己記述システムのためのドメイン固有言語

Fowler[6]は、Rubyがその柔軟な構文、ブロック構造、メタプログラミング機能により、内部DSLのホスト言語として優れていることを確立した。この基盤により、KairosChainは人間が読める仕様であると同時に機械実行可能なコードでもあるスキル定義を作成できる—これは自己参照システムにとって重要な要件である。

---

## 3. システム設計

### 3.1 なぜRuby DSLか：自己改変のための言語選択

KairosChainがスキル定義にRuby DSLを選択したのは、自己改変システムの独自の要件に基づいた意図的なものである。自己参照スキルシステムは、3つの制約を同時に満たす必要がある：

1. **静的解析可能性**: スキルはセキュリティ検証のために実行なしで構文解析可能でなければならない
2. **実行時修正可能性**: システムは運用中にスキルを追加、修正、または制約できなければならない
3. **人間可読性**: スキル定義はドメインエキスパートが読める仕様として機能すべきである

Rubyは、その機能の組み合わせによってこれら3つの制約をすべて独自に満たす：

**表現力豊かなDSL構文。** Rubyのブロック構文（`do...end`）、省略可能な括弧、柔軟なメソッド定義により、自然言語の仕様のように読めるスキル定義が可能になる：

```ruby
skill :core_safety do
  version "1.0"
  guarantees { immutable; always_enforced }
  evolve { deny :all }
  content <<~MD
    ## コア安全不変条件
    1. 進化には明示的な有効化が必要
    2. デフォルトで人間の承認が必要
  MD
end
```

PythonやJavaScriptで同等のものを書くには、かなり多くの構文的なスキャフォールディングが必要となり、可読性が低下し、仕様と実装の間のギャップが広がる。

**動的イントロスペクションを伴う静的AST。** Rubyは標準ライブラリに`Ripper`と`RubyVM::AbstractSyntaxTree`を提供し、実行なしでスキル定義の静的解析を可能にする。これにより、コードが実行される前にセキュリティ検証（危険な構造のチェック）が可能になる。同時に、Rubyの`define_method`、`class_eval`、オープンクラスは、スキルの実行時修正を可能にする—進化機能に不可欠である。

**標準ライブラリの完全性。** JavaScript（Babel/Acornが必要）やPython（限定的な`ast`モジュール）とは異なり、RubyのAST操作には外部依存関係が不要である。Ruby 3.4+ではPrismパーサーでこれがさらに標準化される。これにより、セキュリティクリティカルなシステムの攻撃対象領域とデプロイの複雑さが軽減される。

**実績のあるDSLエコシステム。** RubyのDSL設計パターンは、Rails（Webフレームワーク DSL）、RSpec（テストDSL）、Rake（ビルドDSL）、Sinatra（ルーティングDSL）で20年以上にわたり実戦テストされてきた。これらは、Ruby DSLが数百万のユーザーを持つ本番システムにスケールすることを実証している。

自己改変AIシステムにとって、Rubyは実用的な最適解を表す：読みやすいスキル仕様には十分に表現力があり、実行時進化には十分に強力であり、セキュリティ検証には十分に解析可能である。

### 3.2 Minimum-Nomic原則

KairosChainは、AIシステムのためのMinimum-Nomic原則と呼ぶものを実装している：

- **修正可能なルール**: スキル（能力、行動、制約）は修正可能
- **不変の履歴**: 誰が、何を、いつ、どのように変更したかは永久に記録される
- **制御された進化**: 変更には明示的な有効化と、デフォルトでは人間の承認が必要

これにより、2つの極端を回避する：完全に固定されたルール（適応なし）と無制限の自己修正（混沌）。結果は、進化可能だが監査可能なシステムである。

この原則は自己参照制約にまで拡張される：**スキルの修正はスキル自体によって制約される**。これにより意図的なブートストラップ問題が生じる—進化の仕組みを変更するには、現在の進化ルールに従わなければならない。ルールは適切なチャネルを通じて修正可能でありながら、不正な修正から自らを保護する。

### 3.3 Pure Agent Skills

KairosChainはスキルをドキュメントとしてではなく、Ruby DSLを使用した実行可能な構造として定義する。「Pure」という用語は関数型プログラミングの純粋関数からアナロジーを引いている：明示的なルールを通じて自身の修正を制約し、副作用を最小化し、参照透過性を維持するスキル。この意味で、Pure Agent Skillsは*進化可能な内部言語*—自己記述的で自己制約的な能力定義のシステム—を形成する。

各スキル定義には以下が含まれる：

- **Version**: 変更追跡のためのセマンティックバージョニング
- **Guarantees**: スキルが維持する不変条件（例：`immutable`、`always_enforced`）
- **Evolve rules**: スキルのどの側面が誰によって修正可能か
- **Behavior**: 実行可能なロジック（オプション、イントロスペクション機能用）
- **Content**: 人間が読めるドキュメントと指示

各スキル定義は抽象構文木（AST）に解析され、意味的な差分比較が可能になる。スキルが変更されると、KairosChainはAST差分を計算し、前の状態と新しい状態の両方のハッシュを記録する。

### 3.4 階層型スキルアーキテクチャ

KairosChainは、知識管理のための法体系に着想を得た階層型アーキテクチャを実装している。この設計は、すべての知識が同じレベルの制約や監査可能性を必要とするわけではないことを認識している：

| レイヤー | 法的アナロジー | パス | ブロックチェーン記録 | 可変性 |
|---------|---------------|------|-------------------|--------|
| L0-A | 憲法 | `skills/kairos.md` | なし | 読み取り専用（人間管理） |
| L0-B | 法律 | `skills/kairos.rb` | 完全なトランザクション | 人間の承認が必要 |
| L1 | 政令 | `knowledge/` | ハッシュ参照のみ | 軽量な制約 |
| L2 | 通達 | `context/` | なし | 自由な修正 |

**L0: Kairosコア。** 基盤レイヤーには自己修正に関するメタルールが含まれる。`kairos.md`はシステムの哲学と原則を具現化し—不変であり、人間の合意を通じてシステム外で管理される。`kairos.rb`は進化を統治する実行可能なメタスキルを含む：

- `core_safety`: 不変の安全不変条件（`evolve deny :all`）
- `evolution_rules`: スキルがどのように進化できるかの制約
- `layer_awareness`: レイヤーアーキテクチャの理解
- `approval_workflow`: 人間の承認プロセス定義
- `self_inspection`: 自身の能力を検査する能力
- `chain_awareness`: ブロックチェーン状態の理解

**L1: 知識レイヤー。** Anthropic Skills形式（YAMLフロントマター + Markdown）のプロジェクト固有の普遍的知識。変更はブロックチェーン上のハッシュ参照で追跡されるが、人間の承認は必要ない。コーディング規約、アーキテクチャドキュメント、ドメイン知識に適している。

**L2: コンテキストレイヤー。** AIの作業仮説とセッションノートのための一時的なコンテキスト。ブロックチェーン記録なしで、自由な探索が可能。このレイヤーはAIエージェントに永続的な記録なしで実験する自由を提供し、一方でL0とL1は永続する決定に対する説明責任を維持する。

### 3.5 メタ台帳としてのブロックチェーン

オンチェーンの最小データ構造はSkillStateTransitionである：

| フィールド | 説明 |
|-----------|------|
| skill_id | スキル識別子 |
| prev_ast_hash | 前のASTのSHA-256ハッシュ |
| next_ast_hash | 新しいASTのSHA-256ハッシュ |
| diff_hash | AST差分のSHA-256ハッシュ |
| actor | "Human" / "AI" / "System" |
| agent_id | エージェント識別子 |
| timestamp | ISO 8601タイムスタンプ |
| reason_ref | 変更理由へのオフチェーン参照 |

ASTコンテンツと詳細な差分はオフチェーンに保存される；オンチェーンにはハッシュのみが表示され、監査可能性とストレージ効率のバランスを取る。

---

## 4. アーキテクチャ

```
┌──────────────────────────────────────────────────────────────────┐
│                    MCPクライアント（AIエージェント）                 │
│                   Cursor / Claude Code / etc.                    │
└─────────────────────────────┬────────────────────────────────────┘
                              │ JSON-RPC (STDIO)
                              ▼
┌──────────────────────────────────────────────────────────────────┐
│                    KairosChain MCPサーバー                        │
│  ┌────────────────────────────────────────────────────────────┐  │
│  │  L0: Kairosコア（完全なブロックチェーン記録）                  │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │  │
│  │  │ kairos.md   │  │ kairos.rb   │  │   Safe Evolver      │ │  │
│  │  │ （哲学）     │  │（メタルール）│  │   （承認）           │ │  │
│  │  │ [読取専用]   │  │ [Ruby DSL]  │  │   [ワークフロー]     │ │  │
│  │  └─────────────┘  └──────┬──────┘  └─────────────────────┘ │  │
│  │                          │ AST解析 & 進化                    │  │
│  │                          ▼                                  │  │
│  │                   ┌─────────────────────┐                   │  │
│  │                   │   Kairosモジュール    │                   │  │
│  │                   │  （自己参照）         │                   │  │
│  │                   └─────────────────────┘                   │  │
│  ├────────────────────────────────────────────────────────────┤  │
│  │  L1: 知識レイヤー（ハッシュのみのブロックチェーン記録）         │  │
│  │  ┌──────────────────────────────────────────────────────┐  │  │
│  │  │  knowledge/ (Anthropic Skills形式)                   │  │  │
│  │  │  - プロジェクト規約、アーキテクチャ、ドメインルール      │  │  │
│  │  └──────────────────────────────────────────────────────┘  │  │
│  ├────────────────────────────────────────────────────────────┤  │
│  │  L2: コンテキストレイヤー（ブロックチェーン記録なし）          │  │
│  │  ┌──────────────────────────────────────────────────────┐  │  │
│  │  │  context/ （一時的な仮説、セッションノート）            │  │  │
│  │  └──────────────────────────────────────────────────────┘  │  │
│  └────────────────────────────────────────────────────────────┘  │
│                             │ コミット                           │
│  ┌──────────────────────────▼─────────────────────────────────┐  │
│  │                   ブロックチェーンレイヤー                    │  │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │  │
│  │  │   ブロック   │  │   チェーン   │  │   マークルツリー      │ │  │
│  │  │  (SHA-256)  │─▶│  （不変）    │─▶│    （証明）          │ │  │
│  │  └─────────────┘  └─────────────┘  └─────────────────────┘ │  │
│  └────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────┘

図1: KairosChain階層型システムアーキテクチャ
```

アーキテクチャは3つの主要な関心事で構成される：

1. **階層型スキル管理**: L0（Kairosコア）は完全なブロックチェーン記録と人間の承認でメタルールを管理する。L1（知識）はハッシュのみの記録でプロジェクト知識を保存する。L2（コンテキスト）はAI探索のための自由なワークスペースを提供する。

2. **Kairosモジュールを介した自己参照**: AIエージェントはKairosモジュールを通じて自身のスキル定義を検査でき、利用可能なスキルのリスト表示、進化権限の確認、制約の理解などのイントロスペクティブな機能を可能にする。

3. **ブロックチェーンレイヤー**: スキル状態遷移を不変に記録する。各ブロックにはトランザクションのマークルルートが含まれ、過去の状態の効率的な検証を可能にする。

KairosChainはModel Context Protocol（MCP）サーバーとして実装されており、Claude CodeやCursorなどのMCP互換AIエージェントとのシームレスな統合を可能にする。

---

## 5. 議論

### 5.1 透明性と進化可能性

KairosChainは、透明性と進化可能性が相互に排他的である必要がないことを実証している。変更を防止するのではなく変更の履歴を記録することで、システムは監査可能性を維持しながらAI能力の成長を可能にする。これはMinimum-Nomic原則と一致する：ゲーム（AI操作）は進化できるが、その進化は常に観察可能である。

### 5.2 制限事項

現在の制限事項には以下が含まれる：(1) 詳細なASTデータのオフチェーンストレージへの依存、(2) 初期実装でのシングルノード運用、(3) スキル定義がエージェントの能力を適切にキャプチャするという仮定。階層型アーキテクチャは、異なるタイプの知識に適切な抽象化レベルを提供することで、3番目の制限に部分的に対処している。

### 5.3 チーム運用とガバナンスの複雑性

現在の実装は、スキル進化のための単一承認者モデルを想定している。KairosChainがチーム環境にデプロイされる場合、追加のガバナンスメカニズムが必要になる：

**投票システム。** チーム全体に影響するL0の変更には、マルチシグネチャまたは投票メカニズムが必要になる場合がある。これにより複雑さが導入される：

- 定足数要件（最小参加閾値）
- 承認閾値（単純過半数、特別多数決、全会一致）
- 投票期間と締め切り
- 重要な変更に対する拒否権

**チームサイズ別の推奨アプローチ：**

| チームサイズ | 推奨アプローチ |
|-------------|---------------|
| 個人 | 現在の単一承認者モデル |
| 小規模（2-5人） | 非公式な合意形成によるGitベースの共有 |
| 中規模（5-20人） | 投票ツール付きHTTP API（`governance_propose`、`governance_vote`） |
| 大規模（20人以上） | オンチェーン投票を伴う完全なDAO形式のガバナンス |

**kairos.mdの特別な考慮事項。** 「憲法」レイヤーとして、`kairos.md`への変更は自動化されたシステム外で人間の熟議を通じて行われるべきである（例：GitHub Discussions、チームミーティング）。これにより、基盤となる哲学の変更が自動化されたワークフローの対象になるのではなく、適切な精査を受けることが保証される。

### 5.4 パブリックブロックチェーン拡張の考慮事項

KairosChainは現在プライベートブロックチェーンとして運用されているが、パブリックチェーンへの拡張にはいくつかの考慮事項がある：

**ガスコスト。** すべてのスキル遷移をEthereumメインネットに記録することは、法外に高価になる。推奨パターンは*定期的ハッシュアンカリング*である：プライベートチェーンに遷移を蓄積し、定期的にマークルルートのみをパブリックチェーンにコミットする。これにより、トランザクションごとのコストなしでパブリック検証可能性を提供する。

**プライバシーの懸念。** 企業のスキル定義には独自の知識が含まれる可能性がある。パブリックチェーンへの完全な公開は知的財産リスクを生じさせる。ハッシュのみのアンカリングは、コンテンツを明らかにすることなく検証可能性（特定の時点で状態が存在したことの証明）を保持する。

**パブリック拡張のための推奨アーキテクチャ：**

```
プライベートKairosChain                  パブリックチェーン（Ethereum L2）
       │                                        │
       │  遷移を蓄積                             │
       │         │                              │
       ▼         ▼                              │
  マークルルート（週次）─────────────────────────▶ アンカートランザクション
       │                                        │
       │  証明生成                               │
       ▼                                        ▼
  マークル証明 ◀────────────────────────────── 検証
```

**レイヤー2ソリューション。** より頻繁なパブリックアンカリングを必要とするアプリケーションには、Ethereum L2ソリューション（Optimism、Arbitrum、Base）または専用ロールアップがセキュリティ保証を維持しながらコストを大幅に削減する。

### 5.5 実験的観察：自己参照的改善

KairosChainの自己改変能力を検証するため、KairosChainを使ってKairosChain自身を改良する実験を行った。AIエージェント（KairosChain MCPを有効にしたCursor）に、自身のコードベースを分析し、コーディング規約を抽出し、L1知識として永続化するよう指示した。

**実験環境:**
- 環境: Cursor IDE (2.3.41) + KairosChain MCPサーバー
- 日時: 2026年1月18日
- タスク: `lib/kairos_mcp/`からRubyスタイル規約を抽出しL1に保存

**手順:**
1. AIが`lib/kairos_mcp/`内の実際のコードを分析
2. 命名規則、エラーハンドリングパターン、Rubyイディオムを抽出
3. `knowledge_update`を使用してL1に`ruby_style_guide`を作成
4. `knowledge_get`を使用して作成を検証
5. `chain_history`を使用してブロックチェーン記録を確認

**結果:**

以下のブロックチェーン記録が作成された：

```
Block #1
├── Type: knowledge_update
├── Layer: L1
├── Knowledge ID: ruby_style_guide
├── Action: create
├── Content Hash: ae04bf58...
├── Reason: "KairosChain self-improvement: Extract Ruby style 
│           conventions from actual codebase"
└── Timestamp: 2026-01-18T11:51:24+01:00
```

**解釈:**

この実験はKairosChainのいくつかの重要な特性を実証している：

1. **自己参照能力**: システムは自身のコードを正常に分析し、意味のあるパターンを抽出した—これは自己改善の基盤となる自己検査の一形態である。

2. **L1レイヤーの機能**: 知識は設計通り、適切なレイヤー（L1）にハッシュのみのブロックチェーン記録とともに永続化された。コンテンツハッシュ`ae04bf58...`は、オンチェーンに完全なコンテンツを保存することなく検証可能性を提供する。

3. **不変の監査証跡**: 理由フィールド（"KairosChain self-improvement..."）とタイムスタンプにより、変更がなぜ、いつ発生したかの監査可能な記録が作成される。

4. **メタ的デモンストレーション**: これは単なるドキュメント生成ではない—システムが自身を改善するための知識を、自身のインフラストラクチャ内に記録したものである。あなたが今読んでいるこの論文自体も、このワークフローを使用して改善された。

完全なデモンストレーションログは以下で参照可能: [cursor_kairoschain_demo_log_20260118_jp.md](cursor_kairoschain_demo_log_20260118_jp.md)

ソースコード: [https://github.com/masaomi/KairosChain_2026](https://github.com/masaomi/KairosChain_2026)

### 5.6 今後の方向性

計画されている拡張には以下が含まれる：

1. **Ethereumハッシュアンカリング**: 外部検証可能性のためのパブリックチェーンへの定期的アンカリング
2. **マルチエージェント連携**: `agent_id`を介した複数AIエージェントの追跡とクロスエージェントスキル共有
3. **ゼロ知識証明**: スキル状態のプライバシー保護検証
4. **Webダッシュボード**: スキル進化履歴とガバナンス決定の可視化
5. **ガバナンスツール**: チームデプロイメントのための投票と提案メカニズム

---

## 6. 結論

KairosChainは、AI出力が正しいかどうかではなく、AIの能力がどのように形成されたかに焦点を当てることで、AI説明可能性への新しいアプローチを提供する。Pure Agent Skills（実行可能なRuby DSL定義）とMinimum-Nomic原則（不変の履歴を伴う修正可能なルール）を組み合わせることで、KairosChainはAIスキル進化の監査可能な証跡を作成する。

階層型アーキテクチャ—憲法、法律、政令、通達を分離する—は、異なるタイプの知識に適切な制約レベルを可能にする。この法体系に着想を得た設計は、すべての知識が同じレベルの精査を必要とするわけではないことを認識している：一時的な仮説は自由に探索可能であるべきであり、コアな安全ルールは不変でなければならない。

スキル定義言語としてのRuby DSLの選択は偶発的ではなく本質的である。Rubyの表現力豊かな構文、標準ライブラリのASTツール、ランタイムメタプログラミング機能のユニークな組み合わせにより、人間が読め、静的に解析可能で、動的に進化可能でなければならない自己改変システムに理想的に適している。

AIシステムがますます自律的で高性能になるにつれて、その能力形成の因果プロセスを検証する能力が不可欠になる。KairosChainはこの目標に向けた具体的なステップを提供する：「この知性はどのように形成されたか？」という問いに答えるメタ台帳である。

究極的に、KairosChainは人間とAIシステムの共進化のための最小限かつ検証可能な制度設計を提供することを目指している。

---

## 参考文献

[1] A. Priyanshu, Y. Maurya, and Z. Hong, "AI Governance and Accountability: An Analysis of Anthropic's Claude," *arXiv preprint arXiv:2407.01557*, 2024.

[2] D. Yu, S. Kaur, A. Gupta, J. Brown-Cohen, A. Goyal, and S. Arora, "Skill-Mix: A Flexible and Expandable Family of Evaluations for AI Models," *arXiv preprint arXiv:2310.17567*, 2023.

[3] M. Hatakeyama and T. Hashimoto, "Minimum Nomic: A Tool for Studying Rule Dynamics," *Artificial Life and Robotics*, vol. 13, no. 2, pp. 500–503, 2009. DOI: 10.1007/s10015-008-0605-6

[4] Anthropic, "Agent Skills," *Claude Documentation*, 2025. [Online]. Available: https://docs.anthropic.com/en/docs/agents-and-tools/agent-skills

[5] P. Suber, *The Paradox of Self-Amendment: A Study of Logic, Law, Omnipotence, and Change*. New York: Peter Lang, 1990. ISBN: 978-0820412122

[6] M. Fowler, *Domain-Specific Languages*. Boston: Addison-Wesley, 2010. ISBN: 978-0321712943

---

## DOIと引用

本論文はZenodoで公開されています。

**推奨引用形式：**

Hatakeyama, M. (2026). KairosChain: Pure Agent Skills with Self-Amendment for Auditable AI Evolution. Version 2.1. Zenodo. https://doi.org/10.5281/zenodo.18289164

---

*バージョン 2.1 — 2026年1月18日*
