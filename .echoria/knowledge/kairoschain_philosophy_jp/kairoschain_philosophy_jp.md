---
name: kairoschain_philosophy_jp
description: KairosChainの哲学、アーキテクチャ、レイヤー設計
version: 1.0
layer: L1
tags: [documentation, readme, philosophy, architecture, layers, data-model]
readme_order: 1
readme_lang: jp
---

## 哲学

### 問題

LLM/AIエージェントにおける最大のブラックボックスは：

> **現在の能力がどのように形成されたかを説明できないこと。**

- プロンプトは揮発的
- ツール呼び出し履歴は断片的
- スキルの進化（再定義、合成、削除）は痕跡を残さない

その結果、AIは以下のような場合でも**因果プロセスを第三者が検証できない**存在となります：
- より高い能力を獲得した
- 動作が変化した
- 潜在的に危険になった

### 解決策：KairosChain

KairosChainはこれに以下のように対処します：

1. **スキルを実行可能な構造として定義**（Ruby DSL）、単なるドキュメントではなく
2. **すべてのスキル変更を不変のブロックチェーンに記録**
3. **自己参照を可能にし**、AIが自身の能力を検査できる
4. **安全な進化を強制**、承認ワークフローと不変性ルールで

KairosChainはプラットフォーム、通貨、DAOではありません。**メタ台帳**です — 能力進化の監査証跡です。

### Minimum-Nomicの原則

KairosChainは**Minimum-Nomic**を実装します — 以下のようなシステム：

- ルール（スキル）は**変更可能**
- しかし**誰が**、**いつ**、**何を**、**どのように**変更したかは常に記録され、消去できない

これにより両極端を回避します：
- ❌ 完全に固定されたルール（適応不可）
- ❌ 無制限の自己改変（カオス）

代わりに達成するのは：**進化可能だがゲーム化できないシステム**。

## アーキテクチャ

![KairosChain レイヤーアーキテクチャ](docs/kairoschain_linkedin_diagram.png)

*図：KairosChainの法制度に着想を得たAIスキル管理のためのレイヤーアーキテクチャ*

### システム概要

```
┌─────────────────────────────────────────────────────────────────┐
│                    MCPクライアント (Cursor / Claude Code)        │
└───────────────────────────────┬─────────────────────────────────┘
                                │ STDIO (JSON-RPC)
                                │   or
                                │ Streamable HTTP (POST /mcp)
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    KairosChain MCPサーバー                        │
│  ┌──────────────┐ ┌──────────────┐ ┌──────────────────────────┐ │
│  │ Server/HTTP  │ │   Protocol   │ │     Tool Registry        │ │
│  │ STDIO/Puma   │ │  JSON-RPC    │ │  23+ツール利用可能       │ │
│  └──────────────┘ └──────────────┘ └──────────────────────────┘ │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                    スキルレイヤー                          │   │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────────────────┐│   │
│  │  │ kairos.rb  │ │ kairos.md  │ │    Kairosモジュール    ││   │
│  │  │ (DSL)      │ │ (Markdown) │ │  (自己参照)            ││   │
│  │  └────────────┘ └────────────┘ └────────────────────────┘│   │
│  └──────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌──────────────────────────────────────────────────────────┐   │
│  │                   ブロックチェーンレイヤー                  │   │
│  │  ┌────────────┐ ┌────────────┐ ┌────────────────────────┐│   │
│  │  │   Block    │ │   Chain    │ │     MerkleTree         ││   │
│  │  │ (SHA-256)  │ │ (JSON)     │ │  (証明生成)            ││   │
│  │  └────────────┘ └────────────┘ └────────────────────────┘│   │
│  └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

## レイヤー化されたスキルアーキテクチャ

KairosChainは、知識管理のための**法制度に着想を得たレイヤーアーキテクチャ**を実装しています：

| レイヤー | 法的類推 | パス | ブロックチェーン記録（操作単位） | 可変性 |
|---------|----------|------|-------------------------------|--------|
| **L0-A** | 憲法 | `skills/kairos.md` | - | 読み取り専用 |
| **L0-B** | 法律 | `skills/kairos.rb` | 完全なトランザクション | 人間の承認が必要 |
| **L1** | 条例 | `knowledge/` | ハッシュ参照のみ | 軽量な制約 |
| **L2** | 指令 | `context/` | なし* | 自由に変更可能 |

*注：L2の個別操作は記録されませんが、[StateCommit](#statecommitツール監査可能性向上)は定期的に全レイヤー（L2含む）をオフチェーンスナップショットとしてキャプチャし、オンチェーンにはハッシュ参照のみを記録します。

### L0：Kairosコア（`skills/`）

KairosChainの基盤。自己改変に関するメタルールを含みます。

- **kairos.md**：哲学と原則（不変、読み取り専用）
- **kairos.rb**：Ruby DSLでのメタスキル（完全なブロックチェーン記録で変更可能）

L0に配置できるのはこれらのメタスキルのみ：
- `l0_governance`, `core_safety`, `evolution_rules`, `layer_awareness`, `approval_workflow`, `self_inspection`, `chain_awareness`, `audit_rules`

> **注意：L0自己統治**  
> `l0_governance`スキルは、どのスキルがL0に存在できるかを定義します。これはPure Agent Skillの原則を実装しています：すべてのL0統治基準はL0自身の中で定義されなければなりません。詳細は[Pure Agent SkillのFAQ](#q-pure-agent-skillとは何ですかなぜ重要ですか)を参照してください。

> **注意：スキル-ツール統一**  
> `kairos.rb`のスキルは`tool`ブロックでMCPツールを定義することもできます。`skill_tools_enabled: true`が設定されている場合、これらのスキルは自動的にMCPツールとして登録されます。つまり、**L0-Bではスキルとツールが統一されています** — `kairos.rb`を編集することでツールの追加、変更、削除ができます（L0の制約が適用：人間の承認が必要、完全なブロックチェーン記録）。

### L1：知識レイヤー（`knowledge/`）

**Anthropic Skillsフォーマット**でのプロジェクト固有の普遍的知識。

```
knowledge/
└── skill_name/
    ├── skill_name.md       # YAMLフロントマター + Markdown
    ├── scripts/            # 実行可能スクリプト (Python, Bash, Node)
    ├── assets/             # テンプレート、画像、CSS
    └── references/         # 参考資料、データセット
```

`skill_name.md`の例：

```markdown
---
name: coding_rules
description: プロジェクトのコーディング規約
version: "1.0"
layer: L1
tags: [style, convention]
---

# コーディングルール

## 命名規則
- クラス名：PascalCase
- メソッド名：snake_case
```

### L2：コンテキストレイヤー（`context/`）

セッション用の一時的なコンテキスト。L1と同じフォーマットですが、**操作単位のブロックチェーン記録なし**。

```
context/
└── session_id/
    └── hypothesis/
        └── hypothesis.md
```

用途：
- 作業仮説
- スクラッチノート
- 試行錯誤的な探索

> **注意**: L2の個別変更は記録されませんが、[StateCommit](#statecommitツール監査可能性向上)機能によりL2の状態も定期的なスナップショット（オフチェーン保存、オンチェーンにはハッシュ参照のみ）にキャプチャできます。

### なぜレイヤーアーキテクチャか？

1. **すべての知識が同じ制約を必要とするわけではない** — 一時的な思考に操作単位のブロックチェーン記録は不要
2. **関心の分離** — Kairosメタルール vs プロジェクト知識 vs 一時的コンテキスト
3. **説明責任を伴うAI自律性** — L2では自由な探索、L1では追跡された変更、L0では厳格な制御
4. **クロスレイヤー監査可能性** — [StateCommit](#statecommitツール監査可能性向上)により全レイヤーを一括でスナップショットし、包括的な監査証跡を実現

## データモデル：SkillStateTransition

すべてのスキル変更は`SkillStateTransition`として記録されます：

```ruby
{
  skill_id: String,        # スキル識別子
  prev_ast_hash: String,   # 前のASTのSHA-256
  next_ast_hash: String,   # 新しいASTのSHA-256
  diff_hash: String,       # 差分のSHA-256
  actor: String,           # "Human" / "AI" / "System"
  agent_id: String,        # Kairosエージェント識別子
  timestamp: ISO8601,
  reason_ref: String       # オフチェーン理由参照
}
```
